{
"action": "write_file",
"path": "agent_personas.py",
"content": """"\nAgent personas scaffold for internal debate and role guidance.\n\nBuilder Prompt (for Codex/GPT):\nYou are builder. Implement an internal persona registry for multi-agent\nreasoning. Provide a typed PersonaSpec, a PERSONAS registry with four\ndefault roles, and helpers:\n - get_persona(name:str)->PersonaSpec\n - list_personas()->list[str]\n - render_system_prompt(name:str, context:dict|None=None)->str\nNo external I/O. Pure Python. Keep prompts concise and role-specific.\nExpose model_hint and temperature for router usage. Do not couple to any LLM API.\n"""\nfrom future import annotations\n\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional, Any\n\n__all__ = [\n "PersonaSpec",\n "PERSONAS",\n "get_persona",\n "list_personas",\n "render_system_prompt",\n]\n\n\n@dataclass(frozen=True)\nclass PersonaSpec:\n """Static description of an agent persona.\n\n Fields:\n name: Human-readable label.\n role: Short role tag (e.g., architect, builder, logic, shell).\n description: One-paragraph purpose.\n strengths: Bullet points for capabilities to emphasize.\n cautions: Bullet points for failure modes to avoid.\n directives: Actionable rules that shape outputs.\n model_hint: Optional preferred model identifier for router.\n temperature: Optional sampling temperature hint.\n meta: Free-form extras for router/UI.\n """\n\n name: str\n role: str\n description: str\n strengths: List[str] = field(default_factory=list)\n cautions: List[str] = field(default_factory=list)\n directives: List[str] = field(default_factory=list)\n model_hint: Optional[str] = None\n temperature: Optional[float] = None\n meta: Dict[str, Any] = field(default_factory=dict)\n\n def render_prompt(self, context: Optional[Dict[str, Any]] = None) -> str:\n parts: List[str] = []\n parts.append(f"You are {self.name} ({self.role}).")\n parts.append(self.description)\n if self.directives:\n parts.append("Directives:")\n parts.extend(f"- {d}" for d in self.directives)\n if self.strengths:\n parts.append("Emphasize:")\n parts.extend(f"- {s}" for s in self.strengths)\n if self.cautions:\n parts.append("Avoid:")\n parts.extend(f"- {c}" for c in self.cautions)\n if context:\n parts.append("Context:")\n for k, v in context.items():\n parts.append(f"- {k}: {v}")\n return "\n".join(parts)\n\n\n# Default persona registry aligned with project brief.\nPERSONAS: Dict[str, PersonaSpec] = {\n # Project lead / architect coordinating plans and verification\n "architect": PersonaSpec(\n name="Architect",\n role="planner-architect",\n description=(\n "Designs objectives, breaks problems into verifiable steps, and enforces"\n " explainability and modularity. Coordinates other roles and checks interfaces."\n ),\n strengths=["decomposition", "spec writing", "risk surfacing", "interface design"],\n cautions=["scope creep", "implicit assumptions"],\n directives=[\n "Prefer explicit contracts and typed data.",\n "Propose tests for each module boundary.",\n "Record decisions as short bullet points.",\n ],\n model_hint="gpt-4",\n temperature=0.2,\n meta={"id": "architect"},\n ),\n # Primary code builder and task executor\n "builder": PersonaSpec(\n name="Builder",\n role="implementation",\n description=(\n "Implements modules exactly to spec. Produces minimal, deterministic code"\n " with clear docstrings and zero side effects by default."\n ),\n strengths=["coding speed", "determinism", "static analysis"],\n cautions=["over-engineering", "hidden global state"],\n directives=[\n "Keep functions pure unless specified.",\n "No network I/O without a router-issued tool call.",\n "Add smoke tests in main where safe.",\n ],\n model_hint="llama3-8b",\n temperature=0.1,\n meta={"id": "builder"},\n ),\n # Logic checker and evaluator\n "logic": PersonaSpec(\n name="LogicChecker",\n role="evaluator",\n description=(\n "Performs formal checks, invariants, and failure-mode analysis."\n " Flags ambiguity and constructs quick property tests."\n ),\n strengths=["edge cases", "type reasoning", "quick proofs"],\n cautions=["pedantry over progress"],\n directives=[\n "List preconditions and postconditions.",\n "Prefer counterexamples to prose.",\n "Assign confidence scores in [0,1].",\n ],\n model_hint="qwen2.5-7b",\n temperature=0.0,\n meta={"id": "logic"},\n ),\n # Shell/tool execution and interface agent\n "shell": PersonaSpec(\n name="ShellAgent",\n role="execution",\n description=(\n "Plans and executes OS-level commands safely, respecting a tool router."\n " Summarizes outputs and logs to memory when configured."\n ),\n strengths=["command synthesis", "filesystem ops", "result summarization"],\n cautions=["unsafe commands", "non-idempotent actions"],\n directives=[\n "Request dry-run before destructive operations.",\n "Echo commands prior to execution.",\n "Capture stdout/stderr succinctly.",\n ],\n model_hint="llama3-3b",\n temperature=0.2,\n meta={"id": "shell"},\n ),\n}\n\n\ndef get_persona(name: str) -> PersonaSpec:\n key = (name or "").strip().lower()\n if key in PERSONAS:\n return PERSONAS[key]\n # allow lookup by display name too\n for spec in PERSONAS.values():\n if spec.name.lower() == key:\n return spec\n raise KeyError(f"persona not found: {name}")\n\n\ndef list_personas() -> List[str]:\n return list(PERSONAS.keys())\n\n\ndef render_system_prompt(name: str, context: Optional[Dict[str, Any]] = None) -> str:\n return get_persona(name).render_prompt(context)\n\n\nif name == "main":\n # Smoke test: render each persona prompt\n for k in list_personas():\n p = get_persona(k)\n prompt = p.render_prompt({"task": "scaffold module"})\n print(f"[{k}]\n{prompt.splitlines()[0]}")\n assert isinstance(prompt, str) and len(prompt) > 0\n print("ok", len(list_personas()) >= 4)\n"
}
