{
"action": "write_file",
"path": "io/interface.py",
"content": "'''\nio/interface.py\n\nPurpose:\nProvides a concrete implementation for the command-line interface (CLI), allowing\nthe agent to interact with the user via the terminal.\n'''\n\nfrom __future__ import annotations\n\nimport getpass\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\nfrom datetime import datetime\n\n# Using rich for better console output, as defined in requirements.txt\nfrom rich.console import Console\nfrom rich.prompt import Confirm, Prompt\n\n__all__ = [\n    'EventType',\n    'UserEvent',\n    'OutputMessage',\n    'TokenUsage',\n    'Interface',\n    'CLIInterface',\n]\n\n\nclass EventType(Enum):\n    TEXT = 'TEXT'\n    FILE = 'FILE'\n    BUTTON = 'BUTTON'\n    PLAN_CONFIRM = 'PLAN_CONFIRM'\n    ABORT = 'ABORT'\n\n\n@dataclass\nclass UserEvent:\n    type: EventType\n    payload: Dict[str, Any] = field(default_factory=dict)\n    ts: datetime = field(default_factory=datetime.utcnow)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\n\n@dataclass\nclass OutputMessage:\n    kind: str\n    payload: Dict[str, Any] = field(default_factory=dict)\n    ts: datetime = field(default_factory=datetime.utcnow)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\n\n@dataclass\nclass TokenUsage:\n    model: str\n    input_tokens: int = 0\n    output_tokens: int = 0\n    cost_usd: float = 0.0\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\n\nclass Interface:\n    '''Abstract I/O adapter.'''\n    def fetch_event(self, *, timeout_s: Optional[int] = None) -> UserEvent:\n        raise NotImplementedError('Interface.fetch_event is a scaffold.')\n\n    def send_output(self, message: OutputMessage) -> None:\n        raise NotImplementedError('Interface.send_output is a scaffold.')\n\n    def ask_confirm(self, prompt: str, *, default: bool = True) -> bool:\n        raise NotImplementedError('Interface.ask_confirm is a scaffold.')\n\n    def choose(self, prompt: str, options: List[str], *, multi: bool = False) -> List[str]:\n        raise NotImplementedError('Interface.choose is a scaffold.')\n\n    def get_secret(self, key_name: str) -> str:\n        raise NotImplementedError('Interface.get_secret is a scaffold.')\n\n    def report_usage(self, usages: List[TokenUsage]) -> None:\n        raise NotImplementedError('Interface.report_usage is a scaffold.')\n\n    def notify(self, title: str, body: str, *, level: str = 'info') -> None:\n        raise NotImplementedError('Interface.notify is a scaffold.')\n\n\nclass CLIInterface(Interface):\n    '''Concrete command-line interface implementation.'''\n\n    def __init__(self):\n        self.console = Console()\n\n    def fetch_event(self, *, timeout_s: Optional[int] = None) -> UserEvent:\n        try:\n            user_input = self.console.input('\\n[bold cyan]> [/bold cyan]')\n            return UserEvent(type=EventType.TEXT, payload={'text': user_input})\n        except KeyboardInterrupt:\n            self.console.print('\\n[bold yellow]Abort signal received.[/bold yellow]')\n            return UserEvent(type=EventType.ABORT)\n        except EOFError:\n            self.console.print('\\n[bold yellow]EOF signal received. Exiting.[/bold yellow]')\n            return UserEvent(type=EventType.ABORT)\n\n    def send_output(self, message: OutputMessage) -> None:\n        kind_styles = {\n            'RESULT': 'bold green',\n            'ERROR': 'bold red',\n            'CRITIQUE': 'yellow',\n            'NOTICE': 'cyan',\n            'PLAN': 'bold magenta',\n            'ACTION': 'bold blue',\n            'DEFAULT': 'white',\n        }\n        style = kind_styles.get(message.kind.upper(), kind_styles['DEFAULT'])\n        text = message.payload.get('text', str(message.payload))\n        self.console.print(f'[{style}][{message.kind.upper()}][/{style}] {text}')\n\n    def ask_confirm(self, prompt: str, *, default: bool = True) -> bool:\n        return Confirm.ask(prompt, default=default, console=self.console)\n\n    def choose(self, prompt: str, options: List[str], *, multi: bool = False) -> List[str]:\n        if multi:\n            # rich.prompt does not directly support multi-choice, so we simulate\n            self.console.print(prompt)\n            for i, option in enumerate(options, 1):\n                self.console.print(f'  {i}. {option}')\n            choices_str = Prompt.ask('Enter numbers separated by commas (e.g., 1,3)')\n            try:\n                indices = [int(i.strip()) - 1 for i in choices_str.split(',')]\n                return [options[i] for i in indices if 0 <= i < len(options)]\n            except (ValueError, IndexError):\n                return []\n        else:\n            choice = Prompt.ask(prompt, choices=options, console=self.console)\n            return [choice]\n\n    def get_secret(self, key_name: str) -> str:\n        return getpass.getpass(f'Please enter your {key_name}: ')\n\n    def report_usage(self, usages: List[TokenUsage]) -> None:\n        self.console.print('--- Token Usage Report ---', style='bold cyan')\n        total_cost = 0.0\n        for usage in usages:\n            self.console.print(\n                f'  Model: {usage.model}, In: {usage.input_tokens}, Out: {usage.output_tokens}, Cost: ${usage.cost_usd:.4f}'\n            )\n            total_cost += usage.cost_usd\n        self.console.print(f'[bold]  Total Cost: ${total_cost:.4f}[/bold]')\n\n    def notify(self, title: str, body: str, *, level: str = 'info') -> None:\n        color = 'green' if level == 'info' else 'yellow' if level == 'warn' else 'red'\n        self.console.print(f'[{color}][NOTIFY: {title.upper()}][/{color}] {body}')\n"
}
