{
"action": "write_file",
"path": "planner.py",
"content": "'''\nplanner.py\n\nPurpose\n Scaffold for planning from an active goal into ordered steps.\n No business logic. Method bodies raise NotImplementedError.\n\nIntegration\n - Consumes Goal objects from goal_manager.py\n - Produces Plan/PlanStep structures for core_loop execution\n - Future: persistence adapter; export/import JSON schema\n'''\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Any, Dict, Iterable, List, Optional\nfrom datetime import datetime\n\ntry:\n # Soft import to avoid hard coupling during early scaffolding\n from goal_manager import Goal # type: ignore\nexcept Exception: # pragma: no cover\n Goal = Any # fallback for type checking when module graph is incomplete\n\n__all__ = [\n "PlanStatus",\n "PlanStep",\n "Plan",\n "Planner",\n]\n\n\nclass PlanStatus(Enum):\n PLANNED = "PLANNED"\n IN_PROGRESS = "IN_PROGRESS"\n COMPLETED = "COMPLETED"\n FAILED = "FAILED"\n CANCELLED = "CANCELLED"\n\n\n@dataclass\nclass PlanStep:\n id: str\n desc: str\n deps: List[str] = field(default_factory=list)\n checks: List[str] = field(default_factory=list)\n done: bool = False\n metadata: Dict[str, Any] = field(default_factory=dict)\n created_at: datetime = field(default_factory=datetime.utcnow)\n updated_at: datetime = field(default_factory=datetime.utcnow)\n\n\n@dataclass\nclass Plan:\n id: str\n goal_id: str\n steps: List[PlanStep] = field(default_factory=list)\n status: PlanStatus = PlanStatus.PLANNED\n metadata: Dict[str, Any] = field(default_factory=dict)\n created_at: datetime = field(default_factory=datetime.utcnow)\n updated_at: datetime = field(default_factory=datetime.utcnow)\n\n\nclass Planner:\n """\n Scaffold planner API.\n\n Notes:\n - Deterministic ordering of steps is a design goal but not implemented here.\n - JSON import/export will be added later to align with prompts.planner_template().\n """\n\n def init(self, *, namespace: str = "default", storage_backend: Any | None = None) -> None:\n self.namespace = namespace\n self.storage_backend = storage_backend\n # No initialization logic in scaffold.\n\n def generate_plan(self, goal: Goal, context: Optional[Dict[str, Any]] = None) -> Plan:\n """\n Expand a Goal into a minimal, ordered Plan.\n\n Args:\n goal: Goal instance to plan against.\n context: Optional ambient data (capabilities, constraints, budget).\n\n Returns:\n Plan: Structured plan with steps and initial status.\n\n Raises:\n NotImplementedError: Always in scaffold.\n """\n raise NotImplementedError("Planner.generate_plan is a scaffold.")\n\n def update_step(\n self,\n plan: Plan,\n step_id: str,\n *,\n desc: Optional[str] = None,\n deps: Optional[Iterable[str]] = None,\n checks: Optional[Iterable[str]] = None,\n done: Optional[bool] = None,\n metadata: Optional[Dict[str, Any]] = None,\n ) -> PlanStep:\n """\n Update a step's mutable fields.\n\n Args:\n plan: Target plan.\n step_id: Identifier of the step.\n desc: New description.\n deps: Replace dependencies.\n checks: Replace exit checks.\n done: Mark completion state.\n metadata: Replace metadata.\n\n Returns:\n PlanStep: The updated step.\n\n Raises:\n NotImplementedError: Always in scaffold.\n """\n raise NotImplementedError("Planner.update_step is a scaffold.")\n\n def mark_step_done(self, plan: Plan, step_id: str) -> PlanStep:\n """\n Convenience to mark a step as done and timestamp the update.\n\n Args:\n plan: Target plan.\n step_id: Identifier of the step.\n\n Returns:\n PlanStep: The completed step.\n\n Raises:\n NotImplementedError: Always in scaffold.\n """\n raise NotImplementedError("Planner.mark_step_done is a scaffold.")\n\n def list_steps(self, plan: Plan, *, include_done: bool = True) -> List[PlanStep]:\n """\n Return plan steps with optional filtering.\n\n Args:\n plan: Target plan.\n include_done: Include completed steps if True.\n\n Returns:\n List[PlanStep]: Ordered steps.\n\n Raises:\n NotImplementedError: Always in scaffold.\n """\n raise NotImplementedError("Planner.list_steps is a scaffold.")\n\n def replan(self, plan: Plan, *, reason: str, context: Optional[Dict[str, Any]] = None) -> Plan:\n """\n Produce a revised plan due to failures, surprises, or new info.\n\n Args:\n plan: Existing plan to revise.\n reason: Short justification for audit trail.\n context: Optional new context.\n\n Returns:\n Plan: Revised plan.\n\n Raises:\n NotImplementedError: Always in scaffold.\n """\n raise NotImplementedError("Planner.replan is a scaffold.")\n"
}
