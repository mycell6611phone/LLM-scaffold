{
"action": "write_file",
"path": "planner.py",
"content": """"\nPlanner scaffold for the AGI Modular Mind Loop.\n\nBuilder Prompt (for Codex/GPT):\nYou are builder. Implement planning logic that turns a Goal into a Plan of\nordered steps with explicit dependencies. Keep storage in-memory. Do not call\nexternal tools. Respect these constraints:\n - Pure Python. No DB.\n - Deterministic UUIDs not required; use uuid4.\n - Provide dependency resolution and step readiness detection.\n - Provide serialization to/from dict for Plan and PlanStep.\n - Do not execute steps; only plan and manage lifecycle.\nPublic API to implement or extend later:\n - propose_plan(goal: Goal, context: dict | None) -> Plan [leave unimplemented now]\n - refine_plan(plan_id: str, critique: str | None = None) -> Plan [leave unimplemented now]\n - next_ready_steps(plan_id: str) -> list[PlanStep]\n - update_step(plan_id: str, step_id: str, **fields) -> Plan\n - set_plan_status(plan_id: str, status: PlanStatus) -> Plan\n - list_plans(goal_id: str | None = None) -> list[Plan]\n"""\nfrom future import annotations\n\nfrom dataclasses import dataclass, field, replace, asdict\nfrom enum import Enum, auto\nfrom typing import Dict, List, Optional, Any, Iterable\nfrom datetime import datetime\nimport uuid\n\n# Local import type hints only; avoid runtime dependency cycles.\ntry: # pragma: no cover - optional import for typing\n from goal_manager import Goal # type: ignore\nexcept Exception: # pragma: no cover\n Goal = Any # fallback for type checking when goal_manager not available\n\n__all__ = [\n "StepStatus",\n "PlanStatus",\n "PlanStep",\n "Plan",\n "Planner",\n]\n\n\ndef _now_iso() -> str:\n return datetime.utcnow().isoformat()\n\n\nclass StepStatus(Enum):\n PENDING = auto()\n READY = auto()\n RUNNING = auto()\n DONE = auto()\n FAILED = auto()\n SKIPPED = auto()\n\n @classmethod\n def parse(cls, value: Any) -> "StepStatus":\n if isinstance(value, StepStatus):\n return value\n if isinstance(value, str):\n v = value.strip().upper()\n if v in cls.members:\n return cls[v]\n raise ValueError(f"Invalid StepStatus: {value!r}")\n\n\nclass PlanStatus(Enum):\n DRAFT = auto()\n ACTIVE = auto()\n COMPLETED = auto()\n ABORTED = auto()\n\n @classmethod\n def parse(cls, value: Any) -> "PlanStatus":\n if isinstance(value, PlanStatus):\n return value\n if isinstance(value, str):\n v = value.strip().upper()\n if v in cls.members:\n return cls[v]\n raise ValueError(f"Invalid PlanStatus: {value!r}")\n\n\n@dataclass(frozen=True)\nclass PlanStep:\n id: str = field(default_factory=lambda: str(uuid.uuid4()))\n title: str = ""\n description: str = ""\n inputs: Dict[str, Any] = field(default_factory=dict)\n outputs: Dict[str, Any] = field(default_factory=dict)\n deps: List[str] = field(default_factory=list) # list of step ids\n status: StepStatus = StepStatus.PENDING\n meta: Dict[str, Any] = field(default_factory=dict)\n\n def to_dict(self) -> Dict[str, Any]:\n d = asdict(self)\n d["status"] = self.status.name\n return d\n\n @classmethod\n def from_dict(cls, d: Dict[str, Any]) -> "PlanStep":\n return cls(\n id=d.get("id", str(uuid.uuid4())),\n title=d.get("title", ""),\n description=d.get("description", ""),\n inputs=dict(d.get("inputs", {})),\n outputs=dict(d.get("outputs", {})),\n deps=list(d.get("deps", [])),\n status=StepStatus.parse(d.get("status", StepStatus.PENDING)),\n meta=dict(d.get("meta", {})),\n )\n\n\n@dataclass(frozen=True)\nclass Plan:\n id: str\n goal_id: Optional[str]\n title: str\n status: PlanStatus = PlanStatus.DRAFT\n steps: List[PlanStep] = field(default_factory=list)\n created_at: str = field(default_factory=_now_iso)\n updated_at: str = field(default_factory=_now_iso)\n meta: Dict[str, Any] = field(default_factory=dict)\n\n def to_dict(self) -> Dict[str, Any]:\n return {\n "id": self.id,\n "goal_id": self.goal_id,\n "title": self.title,\n "status": self.status.name,\n "steps": [s.to_dict() for s in self.steps],\n "created_at": self.created_at,\n "updated_at": self.updated_at,\n "meta": dict(self.meta),\n }\n\n @classmethod\n def from_dict(cls, d: Dict[str, Any]) -> "Plan":\n return cls(\n id=d.get("id", str(uuid.uuid4())),\n goal_id=d.get("goal_id"),\n title=d.get("title", ""),\n status=PlanStatus.parse(d.get("status", PlanStatus.DRAFT)),\n steps=[PlanStep.from_dict(x) for x in d.get("steps", [])],\n created_at=d.get("created_at", _now_iso()),\n updated_at=d.get("updated_at", _now_iso()),\n meta=dict(d.get("meta", {})),\n )\n\n\nclass Planner:\n """In-memory plan lifecycle manager.\n\n Responsibilities:\n - Hold Plan objects\n - Manage step updates and readiness detection\n - Provide hooks for future LLM-driven proposal/refinement\n """\n\n def init(self) -> None:\n self._plans: Dict[str, Plan] = {}\n\n # ----- Creation -----\n def create_empty_plan(self, goal: Goal | None = None, title: str | None = None, meta: Optional[Dict[str, Any]] = None) -> Plan:\n pid = str(uuid.uuid4())\n plan = Plan(\n id=pid,\n goal_id=(getattr(goal, "id", None) if goal is not None else None),\n title=title or (getattr(goal, "title", None) or f"Plan {pid[:8]}"),\n status=PlanStatus.DRAFT,\n steps=[],\n created_at=_now_iso(),\n updated_at=_now_iso(),\n meta=dict(meta or {}),\n )\n self._plans[pid] = plan\n return plan\n\n def propose_plan(self, goal: Goal, context: Optional[Dict[str, Any]] = None) -> Plan:\n """LLM-driven plan proposal placeholder. To be implemented later."""\n raise NotImplementedError("propose_plan is not implemented in the scaffold")\n\n def refine_plan(self, plan_id: str, critique: Optional[str] = None) -> Plan:\n """LLM-driven plan refinement placeholder. To be implemented later."""\n raise NotImplementedError("refine_plan is not implemented in the scaffold")\n\n # ----- Accessors -----\n def get_plan(self, plan_id: str) -> Plan:\n p = self._plans.get(plan_id)\n if p is None:\n raise KeyError(f"plan not found: {plan_id}")\n return p\n\n def list_plans(self, goal_id: Optional[str] = None) -> List[Plan]:\n items = list(self._plans.values())\n if goal_id is not None:\n items = [p for p in items if p.goal_id == goal_id]\n # newest first\n items.sort(key=lambda p: p.updated_at, reverse=True)\n return items\n\n # ----- Updates -----\n def set_plan_status(self, plan_id: str, status: PlanStatus) -> Plan:\n p = self.get_plan(plan_id)\n new = replace(p, status=PlanStatus.parse(status), updated_at=_now_iso())\n self._plans[plan_id] = new\n return new\n\n def add_step(\n self,\n plan_id: str,\n title: str,\n description: str = "",\n deps: Optional[List[str]] = None,\n inputs: Optional[Dict[str, Any]] = None,\n meta: Optional[Dict[str, Any]] = None,\n ) -> Plan:\n p = self.get_plan(plan_id)\n step = PlanStep(\n title=title,\n description=description,\n deps=list(deps or []),\n inputs=dict(inputs or {}),\n meta=dict(meta or {}),\n )\n steps = list(p.steps) + [step]\n new = replace(p, steps=steps, updated_at=_now_iso())\n self._plans[plan_id] = new\n return new\n\n def update_step(self, plan_id: str, step_id: str, **fields: Any) -> Plan:\n p = self.get_plan(plan_id)\n idx = _find_step_index(p.steps, step_id)\n step = p.steps[idx]\n allowed = {"title", "description", "inputs", "outputs", "deps", "status", "meta"}\n unknown = set(fields) - allowed\n if unknown:\n raise ValueError(f"Unknown fields: {sorted(unknown)}")\n\n s = step\n if "status" in fields:\n s = replace(s, status=StepStatus.parse(fields["status"]))\n if "title" in fields:\n s = replace(s, title=str(fields["title"]))\n if "description" in fields:\n s = replace(s, description=str(fields["description"]))\n if "inputs" in fields:\n s = replace(s, inputs=dict(fields["inputs"] or {}))\n if "outputs" in fields:\n s = replace(s, outputs=dict(fields["outputs"] or {}))\n if "deps" in fields:\n val = fields["deps"] or []\n if not isinstance(val, Iterable) or isinstance(val, (str, bytes)):\n raise ValueError("deps must be list-like of step ids")\n s = replace(s, deps=list(val))\n if "meta" in fields:\n s = replace(s, meta=dict(fields["meta"] or {}))\n\n steps = list(p.steps)\n steps[idx] = s\n new = replace(p, steps=steps, updated_at=_now_iso())\n self._plans[plan_id] = new\n return new\n\n # ----- Readiness / Dependency resolution -----\n def next_ready_steps(self, plan_id: str) -> List[PlanStep]:\n p = self.get_plan(plan_id)\n done = {s.id for s in p.steps if s.status == StepStatus.DONE}\n ready: List[PlanStep] = []\n for s in p.steps:\n if s.status not in {StepStatus.PENDING, StepStatus.READY}:\n continue\n if all(dep in done for dep in s.deps):\n # Mark READY for visibility but do not mutate status here.\n ready.append(replace(s, status=StepStatus.READY))\n return ready\n\n # ----- Removal -----\n def remove_plan(self, plan_id: str) -> bool:\n if plan_id not in self._plans:\n return False\n del self._plans[plan_id]\n return True\n\n\n# ----- Helpers -----\n\ndef _find_step_index(steps: List[PlanStep], step_id: str) -> int:\n for i, s in enumerate(steps):\n if s.id == step_id:\n return i\n raise KeyError(f"step not found: {step_id}")\n\n\nif name == "main":\n # Minimal smoke test\n pl = Planner()\n plan = pl.create_empty_plan(title="Boot")\n plan = pl.add_step(plan.id, title="Init", description="initialize state")\n plan = pl.add_step(plan.id, title="LoadMemory", deps=[plan.steps[0].id])\n ready = pl.next_ready_steps(plan.id)\n print("ok", len(ready) == 1 and ready[0].title == "Init")\n"
}
