{
"action": "write_file",
"path": "goal_manager.py",
"content": """"\nGoal management module for the AGI Modular Mind Loop.\n\nBuilder Prompt (for Codex/GPT):\nYou are builder. Implement an in-memory GoalManager for hierarchical goals.\nConstraints: pure Python, no DB. Deterministic IDs via uuid4 when not provided.\nExpose methods: add_goal, update_goal, complete_goal, list_goals, remove_goal.\nFilters: status, tag, parent_id. Sorting: priority|created_at|updated_at|title|status.\nOn remove_goal(hard_delete=True): delete and orphan children by setting parent_id=None.\nOn remove_goal(hard_delete=False): set status=CANCELED and update timestamps.\nStatus accepts GoalStatus or case-insensitive str.\nReturn Goal objects. Keep module importable and documented. No CLI.\n"""\nfrom future import annotations\n\nfrom dataclasses import dataclass, field, replace\nfrom enum import Enum, auto\nfrom typing import Dict, List, Optional, Any, Iterable\nfrom datetime import datetime\nimport uuid\n\n__all__ = [\n "GoalStatus",\n "Goal",\n "GoalManager",\n]\n\n\ndef _now_iso() -> str:\n return datetime.utcnow().isoformat()\n\n\nclass GoalStatus(Enum):\n """Lifecycle states for a goal."""\n\n PENDING = auto()\n ACTIVE = auto()\n COMPLETED = auto()\n CANCELED = auto()\n\n @classmethod\n def parse(cls, value: Any) -> "GoalStatus":\n if isinstance(value, GoalStatus):\n return value\n if isinstance(value, str):\n v = value.strip().upper()\n if v in cls.members:\n return cls[v]\n raise ValueError(f"Invalid GoalStatus: {value!r}")\n\n\n@dataclass(frozen=True)\nclass Goal:\n """Structured representation of a goal."""\n\n id: str\n title: str\n description: str = ""\n status: GoalStatus = GoalStatus.PENDING\n priority: int = 5\n tags: List[str] = field(default_factory=list)\n parent_id: Optional[str] = None\n created_at: str = field(default_factory=_now_iso)\n updated_at: str = field(default_factory=_now_iso)\n meta: Dict[str, Any] = field(default_factory=dict)\n\n\nclass GoalManager:\n """In-memory goal lifecycle management.\n\n API:\n add_goal(...)->Goal\n update_goal(goal_id, **fields)->Goal\n complete_goal(goal_id, success=True, summary=None)->Goal\n list_goals(status=None, tag=None, parent_id=None, sort_by="priority", limit=None)->List[Goal]\n remove_goal(goal_id, hard_delete=False)->bool\n """\n\n def init(self, storage_path: Optional[str] = None) -> None:\n self._storage_path = storage_path # reserved for future persistence\n self._goals: Dict[str, Goal] = {}\n\n # -------------------- Creation --------------------\n def add_goal(\n self,\n title: str,\n description: str = "",\n priority: int = 5,\n tags: Optional[List[str]] = None,\n parent_id: Optional[str] = None,\n meta: Optional[Dict[str, Any]] = None,\n goal_id: Optional[str] = None,\n ) -> Goal:\n if not title or not isinstance(title, str):\n raise ValueError("title must be a non-empty string")\n gid = goal_id or str(uuid.uuid4())\n if gid in self._goals:\n raise ValueError(f"goal_id already exists: {gid}")\n if tags is None:\n tags = []\n if meta is None:\n meta = {}\n g = Goal(\n id=gid,\n title=title,\n description=description,\n status=GoalStatus.PENDING,\n priority=int(priority),\n tags=list(tags),\n parent_id=parent_id,\n created_at=_now_iso(),\n updated_at=_now_iso(),\n meta=dict(meta),\n )\n self._goals[g.id] = g\n return g\n\n # -------------------- Update --------------------\n def update_goal(self, goal_id: str, **fields: Any) -> Goal:\n g = self._get(goal_id)\n allowed = {"title", "description", "status", "priority", "tags", "meta", "parent_id"}\n unknown = set(fields) - allowed\n if unknown:\n raise ValueError(f"Unknown fields: {sorted(unknown)}")\n\n new = g\n if "status" in fields:\n new = replace(new, status=GoalStatus.parse(fields["status"]))\n if "title" in fields:\n t = fields["title"]\n if not t or not isinstance(t, str):\n raise ValueError("title must be a non-empty string")\n new = replace(new, title=t)\n if "description" in fields:\n new = replace(new, description=str(fields["description"]))\n if "priority" in fields:\n new = replace(new, priority=int(fields["priority"]))\n if "tags" in fields:\n tags = fields["tags"]\n if tags is None:\n tags = []\n elif not isinstance(tags, Iterable) or isinstance(tags, (str, bytes)):\n raise ValueError("tags must be a list-like of strings")\n new = replace(new, tags=list(tags))\n if "meta" in fields:\n meta = fields["meta"] or {}\n if not isinstance(meta, dict):\n raise ValueError("meta must be a dict")\n new = replace(new, meta=dict(meta))\n if "parent_id" in fields:\n new = replace(new, parent_id=fields["parent_id"]) # None or str\n\n new = replace(new, updated_at=_now_iso())\n self._goals[goal_id] = new\n return new\n\n # -------------------- Complete / Close --------------------\n def complete_goal(\n self,\n goal_id: str,\n success: bool = True,\n summary: Optional[str] = None,\n ) -> Goal:\n g = self._get(goal_id)\n status = GoalStatus.COMPLETED if success else GoalStatus.CANCELED\n meta = dict(g.meta)\n if summary:\n meta["closure_summary"] = str(summary)\n meta["closed_at"] = _now_iso()\n new = replace(g, status=status, updated_at=_now_iso(), meta=meta)\n self._goals[goal_id] = new\n return new\n\n # -------------------- Query / List --------------------\n def list_goals(\n self,\n status: Optional[GoalStatus] = None,\n tag: Optional[str] = None,\n parent_id: Optional[str] = None,\n sort_by: str = "priority",\n limit: Optional[int] = None,\n ) -> List[Goal]:\n items = list(self._goals.values())\n if status is not None:\n status = GoalStatus.parse(status)\n items = [g for g in items if g.status == status]\n if tag is not None:\n items = [g for g in items if tag in g.tags]\n if parent_id is not None:\n items = [g for g in items if g.parent_id == parent_id]\n\n key = self._sort_key(sort_by)\n items.sort(key=key)\n if limit is not None:\n items = items[: int(limit)]\n return items\n\n # -------------------- Removal --------------------\n def remove_goal(self, goal_id: str, hard_delete: bool = False) -> bool:\n if goal_id not in self._goals:\n return False\n if hard_delete:\n # orphan children\n for g in list(self._goals.values()):\n if g.parent_id == goal_id:\n self._goals[g.id] = replace(g, parent_id=None, updated_at=_now_iso())\n del self._goals[goal_id]\n return True\n # soft close\n self._goals[goal_id] = replace(\n self._goals[goal_id], status=GoalStatus.CANCELED, updated_at=_now_iso()\n )\n return True\n\n # -------------------- Internals --------------------\n def _get(self, goal_id: str) -> Goal:\n g = self._goals.get(goal_id)\n if g is None:\n raise KeyError(f"goal not found: {goal_id}")\n return g\n\n @staticmethod\n def _sort_key(sort_by: str):\n s = (sort_by or "priority").lower()\n if s == "priority":\n return lambda g: (g.priority, g.created_at)\n if s == "created_at":\n return lambda g: g.created_at\n if s == "updated_at":\n return lambda g: g.updated_at\n if s == "title":\n return lambda g: g.title.lower()\n if s == "status":\n return lambda g: (g.status.value, g.priority)\n raise ValueError("sort_by must be one of: priority, created_at, updated_at, title, status")\n\n\nif name == "main":\n # Smoke test\n gm = GoalManager()\n g = gm.add_goal("Boot agent")\n gm.update_goal(g.id, status="ACTIVE", priority=1, tags=["boot"])\n gm.complete_goal(g.id, success=True, summary="Initialized")\n roots = gm.list_goals(sort_by="updated_at")\n print("ok", len(roots) >= 1)\n"
}
